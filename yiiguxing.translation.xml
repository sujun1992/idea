<application>
  <component name="AppStorage">
    <histories>
      <item value="A refresh token has its own default scopes, so we should ignore any added by the factory here." />
      <item value="A {@link TokenStore} implementation that just reads data from the tokens themselves. Not really a store since it * never persists anything, and methods like {@link #getAccessToken(OAuth2Authentication)} always return null. But * nevertheless a useful tool since it translates access tokens to and from authentications. Use this wherever a * {@link TokenStore} is needed, but remember to use the same {@link JwtAccessTokenConverter} instance (or one with the same * verifier) as was used when the tokens were minted." />
      <item value="The access token validity period in seconds" />
      <item value="The lifetime in seconds of the access token. For example, the value &quot;3600&quot; denotes that the access token will * expire in one hour from the time the response was generated. This value is OPTIONAL." />
      <item value="Emit the last element observed before complete signal as a {@link Mono}, or emit * {@link NoSuchElementException} error if the source was empty. * For a passive version use {@link #takeLast(int)}" />
      <item value="Turn this {@link Flux} into a hot source and cache last emitted signals for further {@link Subscriber}. Will * retain an unbounded volume of onNext signals. Completion and Error will also be * replayed." />
      <item value="Repeatedly take a value from this {@link Flux} then skip the values that follow * within a given duration. * * &lt;p&gt; * &lt;img class=&quot;marble&quot; src=&quot;doc-files/marbles/sampleFirstAtRegularInterval.svg&quot; alt=&quot;&quot;&gt;" />
      <item value="maximum time period to wait for before raising a" />
      <item value="Subscribe to this {@link Flux} and &lt;strong&gt;block indefinitely&lt;/strong&gt; * until the upstream signals its first value or completes. Returns that value, * or null if the Flux completes empty. In case the Flux errors, the original * exception is thrown (wrapped in a {@link RuntimeException} if it was a checked * exception)." />
      <item value="metrics" />
      <item value="Activate metrics for this sequence, provided there is an instrumentation facade * on the classpath (otherwise this method is a pure no-op)." />
      <item value="Subscribe to this {@link Mono} and &lt;strong&gt;block indefinitely&lt;/strong&gt; until a next signal is * received. Returns that value, or null if the Mono completes empty. In case the Mono * errors, the original exception is thrown (wrapped in a {@link RuntimeException} if * it was a checked exception)." />
      <item value="ubscribe to this {@link Mono} and &lt;strong&gt;block indefinitely&lt;/strong&gt; until a next signal is * received. Returns that value, or null if the Mono completes empty. In case the Mono * errors, the original exception is thrown (wrapped in a {@link RuntimeException} if * it was a checked exception)." />
      <item value="Recover an access token from the converted value. Half the inverse of" />
      <item value="The authentication associated with the token." />
      <item value="Read an access token from the store." />
      <item value="Store an access token." />
      <item value="store Access Token" />
      <item value="The key used for verifying signatures produced by this class. This is not used but * is returned from the endpoint to allow resource servers to obtain the key. * * For an HMAC key it will be the same value as the signing key and does not need to * be set. For and RSA key, it should be set to the String representation of the * public key, in a standard format (e.g. OpenSSH keys)" />
      <item value="Sets the JWT signing key. It can be either a simple MAC key or an RSA key. RSA keys * should be in OpenSSH format, as produced by &lt;tt&gt;ssh-keygen&lt;/tt&gt;." />
      <item value="Verifies signatures using an RSA public key. * * The key can be supplied directly, or as an SSH public or private key string (in * the standard format produced by &lt;tt&gt;ssh-keygen&lt;/tt&gt;)." />
      <item value="Reads RSA key pairs using BC provider classes but without the * need to specify a crypto provider or have BC added as one." />
      <item value="Returns the standard name of the algorithm for this key pair generator. * See the KeyPairGenerator section in the &lt;a href= * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt; * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt; * for information about standard algorithm names." />
      <item value="String is not PEM encoded data" />
      <item value="Assert a boolean expression, throwing an {@code IllegalStateException} * if the expression evaluates to {@code false}. * &lt;p&gt;Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException} * on an assertion failure. * &lt;pre class=&quot;code&quot;&gt;Assert.state(id == null, &quot;The id property must not already be initialized&quot;);&lt;/pre&gt;" />
      <item value="true if the raw password, after encoding, matches the encoded password from * storage" />
      <item value="Verify the encoded password obtained from storage matches the submitted raw * password after it too is encoded. Returns true if the passwords match, false if * they do not. The stored password itself is never decoded." />
      <item value="the hashed password" />
      <item value="Returns the operations performed on hash values bound to the given key." />
      <item value="raw Password" />
      <item value="&lt;p&gt;Sort the {@link HistoricActivityInstance activity instances} in the order in which * they occurred (ie. started) and needs to be followed by {@link #asc()} or {@link #desc()}.&lt;/p&gt; * * &lt;p&gt;The set of all {@link HistoricActivityInstance activity instances} is a &lt;strong&gt;partially * ordered set&lt;/strong&gt;. At a BPMN level this means that instances of concurrent activities (example: * activities on different parallel branched after a parallel gateway) cannot be compared to each other. * Instances of activities which are part of happens-before relation at the BPMN level will be ordered * in respect to that relation.&lt;/p&gt; * * &lt;p&gt;Technically this means that {@link HistoricActivityInstance activity instances} * with different {@link HistoricActivityInstance#getExecutionId() execution ids} are * &lt;strong&gt;incomparable&lt;/strong&gt;. Only {@link HistoricActivityInstance activity instances} with * the same {@link HistoricActivityInstance#getExecutionId() execution id} can be &lt;strong&gt;totally * ordered&lt;/strong&gt; by using {@link #executionId(String)} and {@link #orderPartiallyByOccurrence()} * which will return a result set ordered by its occurrence.&lt;/p&gt;" />
      <item value="Acknowledges the {@link ReceiverRecord} associated with this offset. The offset will be committed * automatically based on the commit configuration parameters {@link ReceiverOptions#commitInterval()} * and {@link ReceiverOptions#commitBatchSize()}. When an offset is acknowledged, it is assumed that * all records in this partition up to and including this offset have been processed. * All acknowledged offsets are committed if possible when the receiver {@link Flux} terminates." />
      <item value="Unavailable For Legal Reasons" />
      <item value="Network Authentication Required" />
      <item value="Unavailable" />
      <item value="Variant Also Negotiates" />
      <item value="Insufficient" />
      <item value="Loop Detected" />
      <item value="Loop" />
      <item value="Detected" />
      <item value="Extended" />
      <item value="添加一个目标主机" />
      <item value="Whether to register the management as a service. Defaults to true" />
      <item value="hether service auto-registration is enabled. Defaults to true." />
      <item value="Enables discovery client health indicators" />
      <item value="Register as a service in consul." />
      <item value="Disable automatic de-registration of service in consul" />
      <item value="IP address to use when accessing service (must also set preferIpAddress to use)." />
      <item value="Should override the host info." />
      <item value="the following configuration is for alternate feign clients if // ribbon is not on the class path. // see corresponding configurations in FeignRibbonClientAutoConfiguration // for load balanced ribbon clients." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="295" />
        <entry key="ENGLISH" value="296" />
        <entry key="IRISH" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="GALICIAN" value="3" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>