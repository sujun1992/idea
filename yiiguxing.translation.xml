<application>
  <component name="AppStorage">
    <histories>
      <item value="raw Password" />
      <item value="&lt;p&gt;Sort the {@link HistoricActivityInstance activity instances} in the order in which * they occurred (ie. started) and needs to be followed by {@link #asc()} or {@link #desc()}.&lt;/p&gt; * * &lt;p&gt;The set of all {@link HistoricActivityInstance activity instances} is a &lt;strong&gt;partially * ordered set&lt;/strong&gt;. At a BPMN level this means that instances of concurrent activities (example: * activities on different parallel branched after a parallel gateway) cannot be compared to each other. * Instances of activities which are part of happens-before relation at the BPMN level will be ordered * in respect to that relation.&lt;/p&gt; * * &lt;p&gt;Technically this means that {@link HistoricActivityInstance activity instances} * with different {@link HistoricActivityInstance#getExecutionId() execution ids} are * &lt;strong&gt;incomparable&lt;/strong&gt;. Only {@link HistoricActivityInstance activity instances} with * the same {@link HistoricActivityInstance#getExecutionId() execution id} can be &lt;strong&gt;totally * ordered&lt;/strong&gt; by using {@link #executionId(String)} and {@link #orderPartiallyByOccurrence()} * which will return a result set ordered by its occurrence.&lt;/p&gt;" />
      <item value="Acknowledges the {@link ReceiverRecord} associated with this offset. The offset will be committed * automatically based on the commit configuration parameters {@link ReceiverOptions#commitInterval()} * and {@link ReceiverOptions#commitBatchSize()}. When an offset is acknowledged, it is assumed that * all records in this partition up to and including this offset have been processed. * All acknowledged offsets are committed if possible when the receiver {@link Flux} terminates." />
      <item value="Unavailable For Legal Reasons" />
      <item value="Network Authentication Required" />
      <item value="Unavailable" />
      <item value="Variant Also Negotiates" />
      <item value="Insufficient" />
      <item value="Loop Detected" />
      <item value="Loop" />
      <item value="Detected" />
      <item value="Extended" />
      <item value="添加一个目标主机" />
      <item value="Whether to register the management as a service. Defaults to true" />
      <item value="hether service auto-registration is enabled. Defaults to true." />
      <item value="Enables discovery client health indicators" />
      <item value="Register as a service in consul." />
      <item value="Disable automatic de-registration of service in consul" />
      <item value="IP address to use when accessing service (must also set preferIpAddress to use)." />
      <item value="Should override the host info." />
      <item value="the following configuration is for alternate feign clients if // ribbon is not on the class path. // see corresponding configurations in FeignRibbonClientAutoConfiguration // for load balanced ribbon clients." />
      <item value="a map of variables that contains an entry for every variable * that was specified at fetching time, if such a variable exists in the task's * ancestor execution hierarchy." />
      <item value="Unsatisfied" />
      <item value="reates a new TypedValue using this type." />
      <item value="is Transient" />
      <item value="the value of the variable which you want to filter" />
      <item value="Define a single variable and its name to filter tasks in a topic. Multiple calls to * this method add to the existing &quot;variable filters&quot;." />
      <item value="the name of the variable you want to fetch and query by" />
      <item value="Define a HashMap of variables and their values to filter correlated tasks. * Calling this method multiple times overrides the previously specified variables." />
      <item value="mplementations are not required to track disposition and as such may never * return {@literal true} even when disposed. However, they MUST only return true * when there's a guarantee the resource or task is disposed." />
      <item value="when the resource or task is disposed" />
      <item value="Disable fetching of byte array and file values. By default, the query will fetch such values. * By calling this method you can prevent the values of (potentially large) blob data chunks * to be fetched. The variables themselves are nonetheless included in the query result." />
      <item value="the flag to enable the priority fetching mechanism" />
      <item value="the id of the worker that completes the task" />
      <item value="&lt;p&gt;Returns at most &lt;code&gt;maxTasks&lt;/code&gt; tasks. The tasks are arbitrarily * distributed among the specified topics. Example: Fetching 10 tasks of topics * &quot;a&quot;/&quot;b&quot;/&quot;c&quot; may return 3/3/4 tasks, or 10/0/0 tasks, etc.&lt;/p&gt;" />
      <item value="May return less than &lt;code&gt;maxTasks&lt;/code&gt; tasks, if there exist not enough * unlocked tasks matching the provided topics or if parallel fetching by other workers * results in locking failures.&lt;/p&gt;" />
      <item value="&lt;p&gt;Returned tasks are locked for the given worker until * &lt;code&gt;now + lockDuration&lt;/code&gt; expires. * Locked tasks cannot be fetched or completed by other workers. When the lock time has expired, * a task may be fetched and locked by other workers.&lt;/p&gt;" />
      <item value="p&gt;Defines fetching of external tasks by using a fluent builder. * The following parameters must be specified: * A worker id, a maximum number of tasks to fetch and a flag that indicates * whether priority should be regarded or not. * The builder allows to specify multiple topics to fetch tasks for and * individual lock durations. For every topic, variables can be fetched * in addition.Is the priority enabled the tasks with the highest priority are fetched.&lt;/p&gt;" />
      <item value="the duration in milliseconds for which tasks should be locked;" />
      <item value="Performs the fetching. Locks candidate tasks of the given topics * for the specified duration." />
      <item value="Variant of JSR-303's {@link javax.validation.Valid}, supporting the * specification of validation groups. Designed for convenient use with * Spring's JSR-303 support but not JSR-303 specific." />
      <item value="Specify one or more validation groups to apply to the validation step * kicked off by this annotation." />
      <item value="pecify one or more validation groups to apply to the validation step * kicked off by this annotation." />
      <item value="rejected" />
      <item value="Attaches callbacks for the resolution and/or rejection of the Promise. * @param onfulfilled The callback to execute when the Promise is resolved. * @param onrejected The callback to execute when the Promise is rejected. * @returns A Promise for the completion of which ever callback is executed." />
      <item value="Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at" />
      <item value="Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License." />
      <item value="SpEL expression that will evaluate whether to include a service in gateway * integration or not, defaults to: true." />
      <item value="change to RouteLocator? use java dsl" />
      <item value="Restore a {@link Flux Flux&amp;lt;VALUE&amp;gt;} from the cache-map given a provided key. * The cache is expected to store original values as a {@link List} of {@link Signal} * of T. If no value is in the cache, it will be calculated from the original source * which is set up in the next step. Note that if the source completes empty, this * result will be cached and all subsequent requests with the same key will return * {@link Flux#empty()}. The behaviour is similar for erroring sources, except cache * hits would then return {@link Flux#error(Throwable)}. * &lt;p&gt; * Note that the wrapped {@link Flux} is lazy, meaning that subscribing twice in a row * to the returned {@link Flux} on an empty cache will trigger a cache miss then a * cache hit." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="267" />
        <entry key="ENGLISH" value="268" />
        <entry key="IRISH" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="GALICIAN" value="3" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>