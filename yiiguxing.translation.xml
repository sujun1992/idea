<application>
  <component name="AppStorage">
    <histories>
      <item value="If this is anything but an empty string, it will be used as a regular * expression to extract part of the input before conversion to the bean * field." />
      <item value="Defines the locale to be used for decoding the argument." />
      <item value="If not specified, the name of the column must be identical to the name * of the field." />
      <item value="A very simple CSV writer released under a commercial-friendly license." />
      <item value="word" />
      <item value="eturns a structured representation of the request path including the * context path + path within application portions, path segments with * encoded and decoded values, and path parameters." />
      <item value="andle returned from the proxy will be an actual asynchronous * {@code Future} that can be used to track the result of the asynchronous method * execution. However, since the target method needs to implement the same signature, * it will have to return a temporary {@code Future} handle that just passes a value * through: e.g. Spring's {@link AsyncResult}, EJB 3.1's {@link javax.ejb.AsyncResult}," />
      <item value="&lt;p&gt;In terms of target method signatures, any parameter types are supported. * However, the return type is constrained to either {@code void} or * {@link java.util.concurrent.Future}. In the latter case, you may declare the * more specific {@link org.springframework.util.concurrent.ListenableFuture} or * {@link java.util.concurrent.CompletableFuture} types which allow for richer * interaction with the asynchronous task and for immediate composition with * further processing steps." />
      <item value="Annotation that marks a method as a candidate for &lt;i&gt;asynchronous&lt;/i&gt; execution. * Can also be used at the type level, in which case all of the type's methods are * considered as asynchronous." />
      <item value="Helper class that simplifies Redis data access code. * &lt;p/&gt; * Performs automatic serialization/deserialization between the given objects and the underlying binary data in the * Redis store. By default, it uses Java serialization for its objects (through {@link JdkSerializationRedisSerializer} * ). For String intensive operations consider the dedicated {@link StringRedisTemplate}. * &lt;p/&gt; * The central method is execute, supporting Redis access code implementing the {@link RedisCallback} interface. It * provides {@link RedisConnection} handling such that neither the {@link RedisCallback} implementation nor the calling * code needs to explicitly care about retrieving/closing Redis connections, or handling Connection lifecycle * exceptions. For typical single step actions, there are various convenience methods. * &lt;p/&gt; * Once configured, this class is thread-safe. * &lt;p/&gt; * Note that while the template is generified, it is up to the serializers/deserializers to properly convert the given * Objects to and from binary data. * &lt;p/&gt; * &lt;b&gt;This is the central class in Redis support&lt;/b&gt;." />
      <item value="String-focused extension of RedisTemplate. Since most operations against Redis are String based, this class provides * a dedicated class that minimizes configuration of its more generic {@link RedisTemplate template} especially in terms * of serializers." />
      <item value="Configure Gson to serialize null fields. By default, Gson omits all fields that are null * during serialization." />
      <item value="Set the {@link ClientHttpRequestFactory} class that should be used with the * {@link RestTemplate}. * @param requestFactory the request factory to use * @return a new builder instance" />
      <item value="Represents a supplier of results." />
      <item value="The ISO-like date-time formatter that formats or parses a date-time with * the offset and zone if available, such as '2011-12-03T10:15:30', * '2011-12-03T10:15:30+01:00' or '2011-12-03T10:15:30+01:00[Europe/Paris]'." />
      <item value="Add additional {@link HttpMessageConverter HttpMessageConverters} that should be * used with the {@link RestTemplate}. Any converters configured on the builder will * replace RestTemplate's default converters." />
      <item value="Naming convention used in languages like C, where words are in lower-case * letters, separated by underscores. * See {@link SnakeCaseStrategy} for details. * * @since 2.7 (was formerly called {@link #CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES})" />
      <item value="Snake Case Strategy" />
      <item value="CAMEL CASE TO LOWER CASE WITH UNDERSCORES" />
      <item value="apply Input Parameters" />
      <item value="Timeout for complete connection establishment (non-negative, * in milliseconds). Zero means no timeout. The timeout counts from the * moment you invoke the connect() method and is cancelled as soon as the * first key-exchange round has finished. It is possible that * the timeout event will be fired during the invocation of the * &lt;code&gt;verifier&lt;/code&gt; callback, but it will only have an effect after * the &lt;code&gt;verifier&lt;/code&gt; returns." />
      <item value="Connect the underlying TCP socket to the server with the given timeout * value (non-negative, in milliseconds). Zero means no timeout." />
      <item value="Connect to the SSH-2 server and, as soon as the server has presented its * host key, use the {@link ServerHostKeyVerifier#verifyServerHostKey(String, * int, String, byte[]) ServerHostKeyVerifier.verifyServerHostKey()} * method of the &lt;code&gt;verifier&lt;/code&gt; to ask for permission to proceed. * If &lt;code&gt;verifier&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then any host key will be * accepted - this is NOT recommended, since it makes man-in-the-middle attackes * VERY easy (somebody could put a proxy SSH server between you and the real server). * &lt;p/&gt; * Note: The verifier will be called before doing any crypto calculations * (i.e., diffie-hellman). Therefore, if you don't like the presented host key then * no CPU cycles are wasted (and the evil server has less information about us). * &lt;p/&gt; * However, it is still possible that the server presented a fake host key: the server * cheated (typically a sign for a man-in-the-middle attack) and is not able to generate * a signature that matches its host key. Don't worry, the library will detect such * a scenario later when checking the signature (the signature cannot be checked before * having completed the diffie-hellman exchange)." />
      <item value="Allocate a pseudo-terminal for this session." />
      <item value="the flag to enable the priority fetching mechanism" />
      <item value="Trusted certificates for verifying the remote endpoint's certificate" />
      <item value="Installs the netty InsecureTrustManagerFactory. This is insecure and not * suitable for production." />
      <item value="Defines property resolution behavior on objects using the JavaBeans component architecture. This * resolver handles base objects of any type, as long as the base is not null. It accepts any object * as a property, and coerces it to a string. That string is then used to find a JavaBeans compliant * property on the base object. The value is accessed using JavaBeans getters and setters. This * resolver can be constructed in read-only mode, which means that isReadOnly will always return * true and {@link #setValue(ELContext, Object, Object, Object)} will always throw * PropertyNotWritableException. ELResolvers are combined together using {@link CompositeELResolver} * s, to define rich semantics for evaluating an expression. See the javadocs for {@link ELResolver} * for details. Because this resolver handles base objects of any type, it should be placed near the * end of a composite resolver. Otherwise, it will claim to have resolved a property before any * resolvers that come after it get a chance to test if they can do so as well." />
      <item value="milliseconds" />
      <item value="Return the HTTP status code (potentially non-standard and not * resolvable through the {@link HttpStatus} enum) as an integer." />
      <item value="Execute the HTTP method to the given URI template, writing the given request entity to the request, and * returns the response as {@link ResponseEntity}." />
      <item value="Converts this instant to the number of milliseconds from the epoch * of 1970-01-01T00:00:00Z." />
      <item value="Converts this instant to the number of milliseconds from the epoch" />
      <item value="Indicator for transience of the value" />
      <item value="which a serialized value can be obtained and specified" />
      <item value="If you have a process instance hierarchy, activating * one process instance from the hierarchy will not activate other * process instances from that hierarchy" />
      <item value="Activates the process instance with the given id" />
      <item value="It is not recommended to use a intermediate catch timer event with a time cycle" />
      <item value="malformed" />
      <item value="cycle" />
      <item value="Whether to dispatch TRACE requests to the FrameworkServlet doService method" />
      <item value="mapping established via an annotation or by previous call to this method," />
      <item value="If a URL pattern of this ServletRegistration is neither the exact target of a security constraint that was established via the ServletSecurity annotation or a previous call to this method, nor the exact target of a security-constraint in the portable deployment descriptor, then this method establishes the security constraint for that pattern from the argument ServletSecurityElement" />
      <item value="Interface through which a {@link Servlet} registered via one of the * &lt;tt&gt;addServlet&lt;/tt&gt; methods on {@link ServletContext} may be further * configured." />
      <item value="Sets the server header value" />
      <item value="Returns the text content of the DOM element without leading and trailing spaces" />
      <item value="Returns the raw text content of the DOM element including all whitespaces" />
      <item value="the number of milliseconds, positive or negative" />
      <item value="Network Authentication Required" />
      <item value="This annotation can be used when deeper Spring integration is required, but at the * expense of portability. Most users should prefer the {@link Endpoint @Endpoint} or * {@link WebEndpoint @WebEndpoint} annotations whenever possible." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="500" />
        <entry key="ENGLISH" value="501" />
        <entry key="IRISH" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="GALICIAN" value="3" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>