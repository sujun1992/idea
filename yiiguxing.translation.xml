<application>
  <component name="AppStorage">
    <histories>
      <item value="Allows providing defaults for" />
      <item value="* Provides integration with the Servlet 3 APIs in addition to the ones found in * {@link HttpServlet25RequestFactory}. The additional methods that are integrated with * can be found below:" />
      <item value="Role prefix must not be null" />
      <item value="A &lt;code&gt;Filter&lt;/code&gt; which populates the &lt;code&gt;ServletRequest&lt;/code&gt; with a request * wrapper which implements the servlet API security methods." />
      <item value="Standard implementation of {@code SecurityFilterChain}." />
      <item value="Commences an authentication scheme. * &lt;p&gt; * &lt;code&gt;ExceptionTranslationFilter&lt;/code&gt; will populate the &lt;code&gt;HttpSession&lt;/code&gt; * attribute named * &lt;code&gt;AbstractAuthenticationProcessingFilter.SPRING_SECURITY_SAVED_REQUEST_KEY&lt;/code&gt; * with the requested target URL before calling this method. * &lt;p&gt; * Implementations should modify the headers on the &lt;code&gt;ServletResponse&lt;/code&gt; as * necessary to commence the authentication process." />
      <item value="Used by {@link ExceptionTranslationFilter} to commence an authentication scheme." />
      <item value="Processes a HTTP request's BASIC authorization headers, putting the result into the * &lt;code&gt;SecurityContextHolder&lt;/code&gt;." />
      <item value="If the {@link SecurityConfigurer} has already been specified get the original, * otherwise apply the new {@link SecurityConfigurerAdapter}." />
      <item value="Allows specifying that URLs are secured by an arbitrary expression" />
      <item value="Lazily initializes the global authentication with a {@link UserDetailsService} if it is * not yet configured and there is only a single Bean of that type. Optionally, if a * {@link PasswordEncoder} is defined will wire this up too." />
      <item value="Indicates whether the user is enabled or disabled. A disabled user cannot be * authenticated." />
      <item value="role should not start with 'ROLE_' since it is automatically inserted" />
      <item value="Specify that URLs require a particular authority." />
      <item value="Shortcut for specifying URLs require a particular role. If you do not want to * have &quot;ROLE_&quot; automatically inserted see {@link #hasAuthority(String)}." />
      <item value="Specify that URLs are allowed by users who have authenticated and were not * &quot;remembered&quot;." />
      <item value="Specify that URLs are allowed by users who have authenticated and were not" />
      <item value="Specify that URLs are allowed by any authenticated user." />
      <item value="Specify that URLs are allowed by anyone." />
      <item value="Maps any request" />
      <item value="Specify that URLs are not allowed by anyone." />
      <item value="Specify that URLs are allowed by users that have been remembered." />
      <item value="Specify that URLs are allowed by anonymous users." />
      <item value="gh-807 Approvals (if any) should only be removed when Refresh Tokens are removed (or expired)" />
      <item value="We don't want to accidentally issue a token, and we have no way to reconstruct the refresh token" />
      <item value="// The token store could remove the refresh token when the // access token is removed, but we want to // be sure..." />
      <item value="Creates a new instance using the provided URL as the location for the JWK Set." />
      <item value="A {@link TokenStore} implementation that provides support for verifying the * JSON Web Signature (JWS) for a JSON Web Token (JWT) using a JSON Web Key (JWK)." />
      <item value="807 Approvals (if any) should only be removed when Refresh Tokens are removed (or expired)" />
      <item value="The key used for verifying signatures produced by this class. This is not used but * is returned from the endpoint to allow resource servers to obtain the key." />
      <item value="Signing and verification RSA keys do not match" />
      <item value="Returns the key in its primary encoding format, or null * if this key does not support encoding." />
      <item value="set Verifier Key" />
      <item value="set Signing Key" />
      <item value="Sets the JWT signing key. It can be either a simple MAC key or an RSA key. RSA keys * should be in OpenSSH format, as produced by &lt;tt&gt;ssh-keygen&lt;/tt&gt;." />
      <item value="The key used for verifying signatures produced by this class. This is not used but * is returned from the endpoint to allow resource servers to obtain the key. * * For an HMAC key it will be the same value as the signing key and does not need to * be set. For and RSA key, it should be set to the String representation of the * public key, in a standard format (e.g. OpenSSH keys)" />
      <item value="e key used for verifying signatures produced by this class. This is not used but * is returned from the endpoint to allow resource servers to obtain the key." />
      <item value="Recover an access token from the converted value. Half the inverse of * {@link #convertAccessToken(OAuth2AccessToken, OAuth2Authentication)}." />
      <item value="A refresh token has its own default scopes, so we should ignore any added by the factory here." />
      <item value="A {@link TokenStore} implementation that just reads data from the tokens themselves. Not really a store since it * never persists anything, and methods like {@link #getAccessToken(OAuth2Authentication)} always return null. But * nevertheless a useful tool since it translates access tokens to and from authentications. Use this wherever a * {@link TokenStore} is needed, but remember to use the same {@link JwtAccessTokenConverter} instance (or one with the same * verifier) as was used when the tokens were minted." />
      <item value="The access token validity period in seconds" />
      <item value="The lifetime in seconds of the access token. For example, the value &quot;3600&quot; denotes that the access token will * expire in one hour from the time the response was generated. This value is OPTIONAL." />
      <item value="Emit the last element observed before complete signal as a {@link Mono}, or emit * {@link NoSuchElementException} error if the source was empty. * For a passive version use {@link #takeLast(int)}" />
      <item value="Turn this {@link Flux} into a hot source and cache last emitted signals for further {@link Subscriber}. Will * retain an unbounded volume of onNext signals. Completion and Error will also be * replayed." />
      <item value="Repeatedly take a value from this {@link Flux} then skip the values that follow * within a given duration. * * &lt;p&gt; * &lt;img class=&quot;marble&quot; src=&quot;doc-files/marbles/sampleFirstAtRegularInterval.svg&quot; alt=&quot;&quot;&gt;" />
      <item value="maximum time period to wait for before raising a" />
      <item value="Subscribe to this {@link Flux} and &lt;strong&gt;block indefinitely&lt;/strong&gt; * until the upstream signals its first value or completes. Returns that value, * or null if the Flux completes empty. In case the Flux errors, the original * exception is thrown (wrapped in a {@link RuntimeException} if it was a checked * exception)." />
      <item value="metrics" />
      <item value="Activate metrics for this sequence, provided there is an instrumentation facade * on the classpath (otherwise this method is a pure no-op)." />
      <item value="Subscribe to this {@link Mono} and &lt;strong&gt;block indefinitely&lt;/strong&gt; until a next signal is * received. Returns that value, or null if the Mono completes empty. In case the Mono * errors, the original exception is thrown (wrapped in a {@link RuntimeException} if * it was a checked exception)." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="336" />
        <entry key="ENGLISH" value="337" />
        <entry key="IRISH" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="GALICIAN" value="3" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>