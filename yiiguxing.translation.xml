<application>
  <component name="AppStorage">
    <histories>
      <item value="Configure Gson to serialize null fields. By default, Gson omits all fields that are null * during serialization." />
      <item value="Set the {@link ClientHttpRequestFactory} class that should be used with the * {@link RestTemplate}. * @param requestFactory the request factory to use * @return a new builder instance" />
      <item value="Represents a supplier of results." />
      <item value="The ISO-like date-time formatter that formats or parses a date-time with * the offset and zone if available, such as '2011-12-03T10:15:30', * '2011-12-03T10:15:30+01:00' or '2011-12-03T10:15:30+01:00[Europe/Paris]'." />
      <item value="Add additional {@link HttpMessageConverter HttpMessageConverters} that should be * used with the {@link RestTemplate}. Any converters configured on the builder will * replace RestTemplate's default converters." />
      <item value="Naming convention used in languages like C, where words are in lower-case * letters, separated by underscores. * See {@link SnakeCaseStrategy} for details. * * @since 2.7 (was formerly called {@link #CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES})" />
      <item value="Snake Case Strategy" />
      <item value="CAMEL CASE TO LOWER CASE WITH UNDERSCORES" />
      <item value="apply Input Parameters" />
      <item value="Timeout for complete connection establishment (non-negative, * in milliseconds). Zero means no timeout. The timeout counts from the * moment you invoke the connect() method and is cancelled as soon as the * first key-exchange round has finished. It is possible that * the timeout event will be fired during the invocation of the * &lt;code&gt;verifier&lt;/code&gt; callback, but it will only have an effect after * the &lt;code&gt;verifier&lt;/code&gt; returns." />
      <item value="Connect the underlying TCP socket to the server with the given timeout * value (non-negative, in milliseconds). Zero means no timeout." />
      <item value="Connect to the SSH-2 server and, as soon as the server has presented its * host key, use the {@link ServerHostKeyVerifier#verifyServerHostKey(String, * int, String, byte[]) ServerHostKeyVerifier.verifyServerHostKey()} * method of the &lt;code&gt;verifier&lt;/code&gt; to ask for permission to proceed. * If &lt;code&gt;verifier&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then any host key will be * accepted - this is NOT recommended, since it makes man-in-the-middle attackes * VERY easy (somebody could put a proxy SSH server between you and the real server). * &lt;p/&gt; * Note: The verifier will be called before doing any crypto calculations * (i.e., diffie-hellman). Therefore, if you don't like the presented host key then * no CPU cycles are wasted (and the evil server has less information about us). * &lt;p/&gt; * However, it is still possible that the server presented a fake host key: the server * cheated (typically a sign for a man-in-the-middle attack) and is not able to generate * a signature that matches its host key. Don't worry, the library will detect such * a scenario later when checking the signature (the signature cannot be checked before * having completed the diffie-hellman exchange)." />
      <item value="Allocate a pseudo-terminal for this session." />
      <item value="the flag to enable the priority fetching mechanism" />
      <item value="Trusted certificates for verifying the remote endpoint's certificate" />
      <item value="Installs the netty InsecureTrustManagerFactory. This is insecure and not * suitable for production." />
      <item value="Defines property resolution behavior on objects using the JavaBeans component architecture. This * resolver handles base objects of any type, as long as the base is not null. It accepts any object * as a property, and coerces it to a string. That string is then used to find a JavaBeans compliant * property on the base object. The value is accessed using JavaBeans getters and setters. This * resolver can be constructed in read-only mode, which means that isReadOnly will always return * true and {@link #setValue(ELContext, Object, Object, Object)} will always throw * PropertyNotWritableException. ELResolvers are combined together using {@link CompositeELResolver} * s, to define rich semantics for evaluating an expression. See the javadocs for {@link ELResolver} * for details. Because this resolver handles base objects of any type, it should be placed near the * end of a composite resolver. Otherwise, it will claim to have resolved a property before any * resolvers that come after it get a chance to test if they can do so as well." />
      <item value="milliseconds" />
      <item value="Return the HTTP status code (potentially non-standard and not * resolvable through the {@link HttpStatus} enum) as an integer." />
      <item value="Execute the HTTP method to the given URI template, writing the given request entity to the request, and * returns the response as {@link ResponseEntity}." />
      <item value="Converts this instant to the number of milliseconds from the epoch * of 1970-01-01T00:00:00Z." />
      <item value="Converts this instant to the number of milliseconds from the epoch" />
      <item value="Indicator for transience of the value" />
      <item value="which a serialized value can be obtained and specified" />
      <item value="If you have a process instance hierarchy, activating * one process instance from the hierarchy will not activate other * process instances from that hierarchy" />
      <item value="Activates the process instance with the given id" />
      <item value="It is not recommended to use a intermediate catch timer event with a time cycle" />
      <item value="malformed" />
      <item value="cycle" />
      <item value="Whether to dispatch TRACE requests to the FrameworkServlet doService method" />
      <item value="mapping established via an annotation or by previous call to this method," />
      <item value="If a URL pattern of this ServletRegistration is neither the exact target of a security constraint that was established via the ServletSecurity annotation or a previous call to this method, nor the exact target of a security-constraint in the portable deployment descriptor, then this method establishes the security constraint for that pattern from the argument ServletSecurityElement" />
      <item value="Interface through which a {@link Servlet} registered via one of the * &lt;tt&gt;addServlet&lt;/tt&gt; methods on {@link ServletContext} may be further * configured." />
      <item value="Sets the server header value" />
      <item value="Returns the text content of the DOM element without leading and trailing spaces" />
      <item value="Returns the raw text content of the DOM element including all whitespaces" />
      <item value="the number of milliseconds, positive or negative" />
      <item value="Network Authentication Required" />
      <item value="This annotation can be used when deeper Spring integration is required, but at the * expense of portability. Most users should prefer the {@link Endpoint @Endpoint} or * {@link WebEndpoint @WebEndpoint} annotations whenever possible." />
      <item value="Identifies a type as being a REST endpoint that is only exposed over Spring MVC or * Spring WebFlux. Mapped methods must be annotated with {@link GetMapping @GetMapping}, * {@link PostMapping @PostMapping}, {@link DeleteMapping @DeleteMapping}, etc annotations * rather than {@link ReadOperation @ReadOperation}, * {@link WriteOperation @WriteOperation}, {@link DeleteOperation @DeleteOperation}." />
      <item value="Decrements the count of the latch, releasing all waiting threads if * the count reaches zero" />
      <item value="determining" />
      <item value="We don't want a hard dependency on Redis to allow traffic. Make sure to set * an alert so you know if this is happening too much. Stripe's observed * failure rate is 0.01%" />
      <item value="Modified" />
      <item value="duration" />
      <item value="span" />
      <item value="trace" />
      <item value="Return the request attribute value if present" />
      <item value="Precondition Required" />
      <item value="Upgrade Required" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="489" />
        <entry key="ENGLISH" value="490" />
        <entry key="IRISH" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="GALICIAN" value="3" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>