<application>
  <component name="AppStorage">
    <histories>
      <item value="Verifies signatures using an RSA public key. * * The key can be supplied directly, or as an SSH public or private key string (in * the standard format produced by &lt;tt&gt;ssh-keygen&lt;/tt&gt;)." />
      <item value="Reads RSA key pairs using BC provider classes but without the * need to specify a crypto provider or have BC added as one." />
      <item value="Returns the standard name of the algorithm for this key pair generator. * See the KeyPairGenerator section in the &lt;a href= * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt; * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt; * for information about standard algorithm names." />
      <item value="String is not PEM encoded data" />
      <item value="Assert a boolean expression, throwing an {@code IllegalStateException} * if the expression evaluates to {@code false}. * &lt;p&gt;Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException} * on an assertion failure. * &lt;pre class=&quot;code&quot;&gt;Assert.state(id == null, &quot;The id property must not already be initialized&quot;);&lt;/pre&gt;" />
      <item value="true if the raw password, after encoding, matches the encoded password from * storage" />
      <item value="Verify the encoded password obtained from storage matches the submitted raw * password after it too is encoded. Returns true if the passwords match, false if * they do not. The stored password itself is never decoded." />
      <item value="the hashed password" />
      <item value="Returns the operations performed on hash values bound to the given key." />
      <item value="raw Password" />
      <item value="&lt;p&gt;Sort the {@link HistoricActivityInstance activity instances} in the order in which * they occurred (ie. started) and needs to be followed by {@link #asc()} or {@link #desc()}.&lt;/p&gt; * * &lt;p&gt;The set of all {@link HistoricActivityInstance activity instances} is a &lt;strong&gt;partially * ordered set&lt;/strong&gt;. At a BPMN level this means that instances of concurrent activities (example: * activities on different parallel branched after a parallel gateway) cannot be compared to each other. * Instances of activities which are part of happens-before relation at the BPMN level will be ordered * in respect to that relation.&lt;/p&gt; * * &lt;p&gt;Technically this means that {@link HistoricActivityInstance activity instances} * with different {@link HistoricActivityInstance#getExecutionId() execution ids} are * &lt;strong&gt;incomparable&lt;/strong&gt;. Only {@link HistoricActivityInstance activity instances} with * the same {@link HistoricActivityInstance#getExecutionId() execution id} can be &lt;strong&gt;totally * ordered&lt;/strong&gt; by using {@link #executionId(String)} and {@link #orderPartiallyByOccurrence()} * which will return a result set ordered by its occurrence.&lt;/p&gt;" />
      <item value="Acknowledges the {@link ReceiverRecord} associated with this offset. The offset will be committed * automatically based on the commit configuration parameters {@link ReceiverOptions#commitInterval()} * and {@link ReceiverOptions#commitBatchSize()}. When an offset is acknowledged, it is assumed that * all records in this partition up to and including this offset have been processed. * All acknowledged offsets are committed if possible when the receiver {@link Flux} terminates." />
      <item value="Unavailable For Legal Reasons" />
      <item value="Network Authentication Required" />
      <item value="Unavailable" />
      <item value="Variant Also Negotiates" />
      <item value="Insufficient" />
      <item value="Loop Detected" />
      <item value="Loop" />
      <item value="Detected" />
      <item value="Extended" />
      <item value="添加一个目标主机" />
      <item value="Whether to register the management as a service. Defaults to true" />
      <item value="hether service auto-registration is enabled. Defaults to true." />
      <item value="Enables discovery client health indicators" />
      <item value="Register as a service in consul." />
      <item value="Disable automatic de-registration of service in consul" />
      <item value="IP address to use when accessing service (must also set preferIpAddress to use)." />
      <item value="Should override the host info." />
      <item value="the following configuration is for alternate feign clients if // ribbon is not on the class path. // see corresponding configurations in FeignRibbonClientAutoConfiguration // for load balanced ribbon clients." />
      <item value="a map of variables that contains an entry for every variable * that was specified at fetching time, if such a variable exists in the task's * ancestor execution hierarchy." />
      <item value="Unsatisfied" />
      <item value="reates a new TypedValue using this type." />
      <item value="is Transient" />
      <item value="the value of the variable which you want to filter" />
      <item value="Define a single variable and its name to filter tasks in a topic. Multiple calls to * this method add to the existing &quot;variable filters&quot;." />
      <item value="the name of the variable you want to fetch and query by" />
      <item value="Define a HashMap of variables and their values to filter correlated tasks. * Calling this method multiple times overrides the previously specified variables." />
      <item value="mplementations are not required to track disposition and as such may never * return {@literal true} even when disposed. However, they MUST only return true * when there's a guarantee the resource or task is disposed." />
      <item value="when the resource or task is disposed" />
      <item value="Disable fetching of byte array and file values. By default, the query will fetch such values. * By calling this method you can prevent the values of (potentially large) blob data chunks * to be fetched. The variables themselves are nonetheless included in the query result." />
      <item value="the flag to enable the priority fetching mechanism" />
      <item value="the id of the worker that completes the task" />
      <item value="&lt;p&gt;Returns at most &lt;code&gt;maxTasks&lt;/code&gt; tasks. The tasks are arbitrarily * distributed among the specified topics. Example: Fetching 10 tasks of topics * &quot;a&quot;/&quot;b&quot;/&quot;c&quot; may return 3/3/4 tasks, or 10/0/0 tasks, etc.&lt;/p&gt;" />
      <item value="May return less than &lt;code&gt;maxTasks&lt;/code&gt; tasks, if there exist not enough * unlocked tasks matching the provided topics or if parallel fetching by other workers * results in locking failures.&lt;/p&gt;" />
      <item value="&lt;p&gt;Returned tasks are locked for the given worker until * &lt;code&gt;now + lockDuration&lt;/code&gt; expires. * Locked tasks cannot be fetched or completed by other workers. When the lock time has expired, * a task may be fetched and locked by other workers.&lt;/p&gt;" />
      <item value="p&gt;Defines fetching of external tasks by using a fluent builder. * The following parameters must be specified: * A worker id, a maximum number of tasks to fetch and a flag that indicates * whether priority should be regarded or not. * The builder allows to specify multiple topics to fetch tasks for and * individual lock durations. For every topic, variables can be fetched * in addition.Is the priority enabled the tasks with the highest priority are fetched.&lt;/p&gt;" />
      <item value="the duration in milliseconds for which tasks should be locked;" />
      <item value="Performs the fetching. Locks candidate tasks of the given topics * for the specified duration." />
      <item value="Variant of JSR-303's {@link javax.validation.Valid}, supporting the * specification of validation groups. Designed for convenient use with * Spring's JSR-303 support but not JSR-303 specific." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="274" />
        <entry key="ENGLISH" value="275" />
        <entry key="IRISH" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="GALICIAN" value="3" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>