<application>
  <component name="AppStorage">
    <histories>
      <item value="lush the entity cache which inserts operations to the db operation manager" />
      <item value="Creates the history event fired when a variable is &lt;strong&gt;created&lt;/strong&gt;." />
      <item value="Migrating Instance" />
      <item value="migrate History" />
      <item value="Decides how to propagate the exception properly, e.g. as bpmn error or &quot;normal&quot; error." />
      <item value="Provides access to the snapshot of latest variables of an execution." />
      <item value="Contains observers which are observe the execution." />
      <item value="persisted reference to the super case execution of this execution" />
      <item value="fire Historic Activity Instance Update" />
      <item value="Dispatches the current delayed variable events and performs the given atomic operation * if the current state was not changed." />
      <item value="efault way of leaving a BPMN 2.0 activity: evaluate the conditions on the * outgoing sequence flow and take those that evaluate to true." />
      <item value="The resulting string may vary depending on the platform's * default encoding. Instead, use the encode(String,String) * method to specify the encoding" />
      <item value="Decrement an integer value stored as string value under {@code key} by one." />
      <item value="decrement" />
      <item value="set If Present" />
      <item value="set If Absent" />
      <item value="delta" />
      <item value="deprecated" />
      <item value="has default methods (made * possible by a Java 8 baseline) and can be implemented directly without the * need for this adapter" />
      <item value="The history level controls what kind of data is logged to the history database. * More formally, it controls which history events are produced by the {@link HistoryEventProducer}.&lt;/p&gt;" />
      <item value="create variable scope for output parameters" />
      <item value="he quote character to be used when writing a CSV file" />
      <item value="If this is anything but an empty string, it will be used as a regular * expression to extract part of the input before conversion to the bean * field." />
      <item value="Defines the locale to be used for decoding the argument." />
      <item value="If not specified, the name of the column must be identical to the name * of the field." />
      <item value="A very simple CSV writer released under a commercial-friendly license." />
      <item value="word" />
      <item value="eturns a structured representation of the request path including the * context path + path within application portions, path segments with * encoded and decoded values, and path parameters." />
      <item value="andle returned from the proxy will be an actual asynchronous * {@code Future} that can be used to track the result of the asynchronous method * execution. However, since the target method needs to implement the same signature, * it will have to return a temporary {@code Future} handle that just passes a value * through: e.g. Spring's {@link AsyncResult}, EJB 3.1's {@link javax.ejb.AsyncResult}," />
      <item value="&lt;p&gt;In terms of target method signatures, any parameter types are supported. * However, the return type is constrained to either {@code void} or * {@link java.util.concurrent.Future}. In the latter case, you may declare the * more specific {@link org.springframework.util.concurrent.ListenableFuture} or * {@link java.util.concurrent.CompletableFuture} types which allow for richer * interaction with the asynchronous task and for immediate composition with * further processing steps." />
      <item value="Annotation that marks a method as a candidate for &lt;i&gt;asynchronous&lt;/i&gt; execution. * Can also be used at the type level, in which case all of the type's methods are * considered as asynchronous." />
      <item value="Helper class that simplifies Redis data access code. * &lt;p/&gt; * Performs automatic serialization/deserialization between the given objects and the underlying binary data in the * Redis store. By default, it uses Java serialization for its objects (through {@link JdkSerializationRedisSerializer} * ). For String intensive operations consider the dedicated {@link StringRedisTemplate}. * &lt;p/&gt; * The central method is execute, supporting Redis access code implementing the {@link RedisCallback} interface. It * provides {@link RedisConnection} handling such that neither the {@link RedisCallback} implementation nor the calling * code needs to explicitly care about retrieving/closing Redis connections, or handling Connection lifecycle * exceptions. For typical single step actions, there are various convenience methods. * &lt;p/&gt; * Once configured, this class is thread-safe. * &lt;p/&gt; * Note that while the template is generified, it is up to the serializers/deserializers to properly convert the given * Objects to and from binary data. * &lt;p/&gt; * &lt;b&gt;This is the central class in Redis support&lt;/b&gt;." />
      <item value="String-focused extension of RedisTemplate. Since most operations against Redis are String based, this class provides * a dedicated class that minimizes configuration of its more generic {@link RedisTemplate template} especially in terms * of serializers." />
      <item value="Configure Gson to serialize null fields. By default, Gson omits all fields that are null * during serialization." />
      <item value="Set the {@link ClientHttpRequestFactory} class that should be used with the * {@link RestTemplate}. * @param requestFactory the request factory to use * @return a new builder instance" />
      <item value="Represents a supplier of results." />
      <item value="The ISO-like date-time formatter that formats or parses a date-time with * the offset and zone if available, such as '2011-12-03T10:15:30', * '2011-12-03T10:15:30+01:00' or '2011-12-03T10:15:30+01:00[Europe/Paris]'." />
      <item value="Add additional {@link HttpMessageConverter HttpMessageConverters} that should be * used with the {@link RestTemplate}. Any converters configured on the builder will * replace RestTemplate's default converters." />
      <item value="Naming convention used in languages like C, where words are in lower-case * letters, separated by underscores. * See {@link SnakeCaseStrategy} for details. * * @since 2.7 (was formerly called {@link #CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES})" />
      <item value="Snake Case Strategy" />
      <item value="CAMEL CASE TO LOWER CASE WITH UNDERSCORES" />
      <item value="apply Input Parameters" />
      <item value="Timeout for complete connection establishment (non-negative, * in milliseconds). Zero means no timeout. The timeout counts from the * moment you invoke the connect() method and is cancelled as soon as the * first key-exchange round has finished. It is possible that * the timeout event will be fired during the invocation of the * &lt;code&gt;verifier&lt;/code&gt; callback, but it will only have an effect after * the &lt;code&gt;verifier&lt;/code&gt; returns." />
      <item value="Connect the underlying TCP socket to the server with the given timeout * value (non-negative, in milliseconds). Zero means no timeout." />
      <item value="Connect to the SSH-2 server and, as soon as the server has presented its * host key, use the {@link ServerHostKeyVerifier#verifyServerHostKey(String, * int, String, byte[]) ServerHostKeyVerifier.verifyServerHostKey()} * method of the &lt;code&gt;verifier&lt;/code&gt; to ask for permission to proceed. * If &lt;code&gt;verifier&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then any host key will be * accepted - this is NOT recommended, since it makes man-in-the-middle attackes * VERY easy (somebody could put a proxy SSH server between you and the real server). * &lt;p/&gt; * Note: The verifier will be called before doing any crypto calculations * (i.e., diffie-hellman). Therefore, if you don't like the presented host key then * no CPU cycles are wasted (and the evil server has less information about us). * &lt;p/&gt; * However, it is still possible that the server presented a fake host key: the server * cheated (typically a sign for a man-in-the-middle attack) and is not able to generate * a signature that matches its host key. Don't worry, the library will detect such * a scenario later when checking the signature (the signature cannot be checked before * having completed the diffie-hellman exchange)." />
      <item value="Allocate a pseudo-terminal for this session." />
      <item value="the flag to enable the priority fetching mechanism" />
      <item value="Trusted certificates for verifying the remote endpoint's certificate" />
      <item value="Installs the netty InsecureTrustManagerFactory. This is insecure and not * suitable for production." />
      <item value="Defines property resolution behavior on objects using the JavaBeans component architecture. This * resolver handles base objects of any type, as long as the base is not null. It accepts any object * as a property, and coerces it to a string. That string is then used to find a JavaBeans compliant * property on the base object. The value is accessed using JavaBeans getters and setters. This * resolver can be constructed in read-only mode, which means that isReadOnly will always return * true and {@link #setValue(ELContext, Object, Object, Object)} will always throw * PropertyNotWritableException. ELResolvers are combined together using {@link CompositeELResolver} * s, to define rich semantics for evaluating an expression. See the javadocs for {@link ELResolver} * for details. Because this resolver handles base objects of any type, it should be placed near the * end of a composite resolver. Otherwise, it will claim to have resolved a property before any * resolvers that come after it get a chance to test if they can do so as well." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="523" />
        <entry key="ENGLISH" value="524" />
        <entry key="IRISH" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="GALICIAN" value="3" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>