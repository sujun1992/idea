<application>
  <component name="AppStorage">
    <histories>
      <item value="Registers an editor class to edit values of the given target class. * If the editor class is {@code null}, * then any existing definition will be removed. * Thus this method can be used to cancel the registration. * The registration is canceled automatically * if either the target or editor class is unloaded." />
      <item value="Set (or change) the object that is to be edited. Primitive types such * as &quot;int&quot; must be wrapped as the corresponding object type such as * &quot;java.lang.Integer&quot;." />
      <item value="coerce" />
      <item value="if the json representation cannot be mapped to the specified type" />
      <item value="Base class for type token classes used both to contain information * and as keys for deserializers" />
      <item value="Maps the json represented by this object to a java object of the given type. * Argument is to be supplied in Jackson's canonical type string format * (see {@link JavaType#toCanonical()})." />
      <item value="Maps the internal representation of a data format to a java object of the * desired class. The type identifier is given in a data format specific format. Its * interpretation is data-format-specific. For example, it can be used to express generic * type information that cannot be expressed by a {@link Class} object." />
      <item value="Maps the wrapped object to a java object. * The object is determined based on the configuration string * which is data format specific" />
      <item value="aps the wrapped object to a java object. * The object is determined based on the configuration string * which is data format specific" />
      <item value="convert" />
      <item value="conver" />
      <item value="if this node is not a array value" />
      <item value="Get this node as list" />
      <item value="Get the field names of this node (i.e. the property names)" />
      <item value="Creates a JsonPath query on this element" />
      <item value="Fetches the node from the result of JsonPath" />
      <item value="if the subtree rooted at this node is a method invocation" />
      <item value="transient" />
      <item value="wrap" />
      <item value="Wrap the given {@code byte} array in a {@code DataBuffer}. Unlike * {@linkplain #allocateBuffer(int) allocating}, wrapping does not use new memory." />
      <item value="his method should be automatically invoked at the end of message * processing so typically applications should not have to invoke it. * If invoked multiple times it should have no side effects." />
      <item value="Indicate that message handling is complete, allowing for any cleanup or * end-of-processing tasks to be performed such as applying header changes * made via {@link #getHeaders()} to the underlying HTTP message (if not * applied already)." />
      <item value="Use the given {@link Publisher} of {@code Publishers} to write the body * of the HttpOutputMessage to the underlying HTTP layer, flushing after * each {@code Publisher&lt;DataBuffer&gt;}." />
      <item value="Contract for specifying request headers leading up to the exchange" />
      <item value="WebHandler that delegates to a chain of {@link GlobalFilter} instances and * {@link GatewayFilterFactory} instances then to the target {@link WebHandler}." />
      <item value="ets the port of the management server, use {@code null} if the * {@link ServerProperties#getPort() server port} should be used. To disable use 0." />
      <item value="that can be used to create the body" />
      <item value="Whether this status code is in the HTTP series" />
      <item value="Public constant media type for {@code application/json;charset=UTF-8}." />
      <item value="Subscribe to this {@link Mono} and &lt;strong&gt;block indefinitely&lt;/strong&gt; until a next signal is * received. Returns that value, or null if the Mono completes empty. In case the Mono * errors, the original exception is thrown (wrapped in a {@link RuntimeException} if * it was a checked exception)." />
      <item value="Note that each block() will trigger a new subscription: in other words, the result * might miss signal from hot publishers." />
      <item value="notify" />
      <item value="Subscribe to this {@link Mono} and &lt;strong&gt;block indefinitely&lt;/strong&gt; until a next signal is * received. Returns that value, or null if the Mono completes empty. In case the Mono * errors, the original exception is thrown (wrapped in a {@link RuntimeException} if * it was a checked exception). * * &lt;p&gt; * &lt;img class=&quot;marble&quot; src=&quot;doc-files/marbles/block.svg&quot; alt=&quot;&quot;&gt; * &lt;p&gt; * Note that each block() will trigger a new subscription: in other words, the result * might miss signal from hot publishers." />
      <item value="Keep in mind that since the sequence can be asynchronous, this will immediately * return control to the calling thread. This can give the impression the consumer is * not invoked when executing in a main thread or a unit test for instance." />
      <item value="Cancel or dispose the underlying task or resource." />
      <item value="Perform the HTTP request and return a {@link ClientResponse} with the * response status and headers. You can then use methods of the response * to consume the body:" />
      <item value="Provides access to every attribute declared so far with the * possibility to add, replace, or remove values." />
      <item value="retrieve" />
      <item value="Provides access to every header declared so far with the possibility * to add, replace, or remove values." />
      <item value="capacity" />
      <item value="reverse" />
      <item value="regex to split by comma which does a positive look ahead to ignore commas enclosed in quotes" />
      <item value="List Transformer" />
      <item value="Defines property resolution behavior on objects using the JavaBeans component architecture. This * resolver handles base objects of any type, as long as the base is not null. It accepts any object * as a property, and coerces it to a string. That string is then used to find a JavaBeans compliant * property on the base object. The value is accessed using JavaBeans getters and setters. This * resolver can be constructed in read-only mode, which means that isReadOnly will always return * true and {@link #setValue(ELContext, Object, Object, Object)} will always throw * PropertyNotWritableException. ELResolvers are combined together using {@link CompositeELResolver} * s, to define rich semantics for evaluating an expression. See the javadocs for {@link ELResolver} * for details. Because this resolver handles base objects of any type, it should be placed near the * end of a composite resolver. Otherwise, it will claim to have resolved a property before any * resolvers that come after it get a chance to test if they can do so as well." />
      <item value="A script which is provided as source code" />
      <item value="evaluate" />
      <item value="ScriptEngine that used JUEL for script evaluation and compilation (JSR-223)." />
      <item value="Bindings implementation using an {@link ExecutionImpl} as 'back-end'" />
      <item value="Returns a cached script engine or creates a new script engine if no such engine is currently cached" />
      <item value="Primitive Value" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="419" />
        <entry key="ENGLISH" value="420" />
        <entry key="IRISH" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="GALICIAN" value="3" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>